#ifndef _LIBNUKEXX_TYPE_TRAITS_
#define _LIBNUKEXX_TYPE_TRAITS_

namespace std
{
    template <typename>
    struct remove_volatile;

    template <typename>
    struct remove_const;

    template <typename T, T v>
    struct integral_constant
    {
        typedef T value_type;
        typedef integral_constant type;

        static constexpr value_type value = v;

        constexpr operator value_type() const
        {
            return value;
        }
    };

    typedef std::integral_constant<bool, true> true_type;
    typedef std::integral_constant<bool, false> false_type;

    template <typename>
    struct __is_integral_helper : false_type
    {
    };

    <% [ "bool", "char16_t", "char32_t" ].each do |type| %>

    template <>
    struct __is_integral_helper<<%= type %>> : true_type
    {
    };

    <% end %>

    <% [ "char" , "short int", "int", "long long int" ].each do |type| %>
    <% [ "signed", "unsigned" ].each do |sign| %>

    template <>
    struct __is_integral_helper<<%= sign %> <%= type %>> : true_type
    {
    };

    <% end %>
    <% end %>

    template <typename T>
    struct is_integral : __is_integral_helper<typename std::remove_cv<T>::type>
    {
    };

    template <typename T, typename U>
    struct is_same : false_type
    {
    };

    template <typename T>
    struct is_same<T, T> : true_type
    {
    };

    template <typename T>
    struct remove_cv
    {
        typedef typename std::remove_volatile<typename std::remove_const<T>::type>::type type;
    };

    template <typename T>
    struct remove_const
    {
        typedef T type;
    };

    template <typename T>
    struct remove_const<const T>
    {
        typedef T type;
    };

    template <typename T>
    struct remove_volatile
    {
        typedef T type;
    };

    template <typename T>
    struct remove_volatile<volatile T>
    {
        typedef T type;
    };
}

#endif
